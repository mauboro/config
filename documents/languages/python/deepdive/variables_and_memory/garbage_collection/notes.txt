So, we already know that when an object's reference count reaches zero, the Python Memory Manager destroys it automatically. But, there are cases when this simply doesn't happen, one of those is the circular reference case. Let's pretend that we have a variable that is serving as a pointer(as it always does) to a value that we'll call value "A", and then A has an instance variable that is pointing to another object called "B", at the moment we destroy the firstly instatiated variable, the reference count on object A will reach zero thus destroying it and the same will happen with object B, much like a domino effect, right? But, with there is an instace variable in object B that is pointing back to object A, when the first variable gets destroyed, the reference count of those two objects will be 1 and not zero, therefore freeing them of the impetuous hand of the Python Memory Manager. This, my fried, is a case of a circular reference, a situation that makes the program suscetible to the much feared memory leaks(don't know what that is yet, should search it up). But fear not, amigo, whenever there is a circular reference, the famous Garbage Collector will be there to identify it properly and clean it up, unless your Python is below version 3.4 and at least one of the objects that compose the circular reference have "__del__()" methods in them, the garbage collector will avoid destroying them because of the relevance that the destruction conducted by the "__del__()" magic method has in the program and will label them as uncollectable objects, but again, there is nothing to worry about since this issue was solved in the version above 3.4. The Garbage Collector can be controlled programatically by the use of the "gc" module(not as in GNU Compiler, plain and simple Garbage Collector, hehe), it is turned on by default and it can be turned off(for performance reasons, but beware of the circular references), it runs periodically if turned on and can be called manually, and even used for your own cleaned.
